<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>还是想来找你</title>
    <link href="/posts/35631.html"/>
    <url>/posts/35631.html</url>
    
    <content type="html"><![CDATA[<p>其实那天我收到消息，我真的还挺惊讶的。因为之前我一直觉着自己是个挺失败的人，特别是在对你这件事上。当时我可能就不是特别敢点开你的聊天窗口了，因为你好像很忙，我还真怕打扰到你，觉得那时候都已经快将近五年没有见了，通过这微信窗口又能表达些啥呢，能够维持这段关系吗？你后来也和我说过，有人牵挂我对我也没啥好处呀，我当时都懵住了，确实是这样，我啥也做不了，只能说这些虚无缥缈的话。而且每天遇到的人和事都不一样，我太不了解你的生活了，就知道你每天很忙很忙…那我想我可能只能先暂时回避，让自己静下来，想着能够慢慢等我把手里的事情一件件完成，我是很有机会来找你的，虽然不知道那时候你在干什么，或者已经有了啥新新生活了（但我感觉这样做是错的，万一你真有新新生活那我不真的啥也没机会了）我心里一直都有你啊，只是我没有来找你。</p><p><img src="https://s1.ax1x.com/2023/04/01/ppROJaT.jpg"></p><p>我靠那两天我是真的没睡好，每次都是6点多就醒了，可能是每天都很期待见到你哈哈哈。我觉得那一天做得最最最错误的事情，就是陪你走了两万七千步…我是真傻啊，你才睡了多久，你却陪我走那么多。在这和你说一声对不起啦…我还是比较喜欢第二天，我其实就是想陪着你，无论在哪里，无论你在干什么，我在干什么，因为你在我边上，我就会很开心，根本不需要去哪里玩呀，哪里逛呀，看你认真工作我就觉得好有意思。我也终于理解你为啥有时候我的消息会石沉大海，这几百个群早把你淹没了。也真的见识到了这份工作的高强度，同时也好心疼你。</p><p>谢谢你愿意在你做完一天的工作以后，还愿意在很晚很晚的时间陪我出去走走，好喜欢和你漫无目的地走着然后说说话，复盘那些我们本身就很少很少的点滴，也再一次让我觉着当时的我有多么糟糕。就其实还挺希望那个晚上能够时间长一些，回去的路能够长一些的，我感觉我还有好多话想和你当面说，因为真的不知道下一次见面到底是啥时候了。我也很庆幸自己最后还是问了你那个问题，我从来没想过你能明确回答这种，我只是单纯地想告诉你，我会继续喜欢你下去，就像你一直是我的动力一样。</p><p>我很感谢你这一次猝不及防地来找我，我对你生活真的比以往只是微信界面的了解得更多了。所以我也不想给自己找一些借口了，还是应该勇敢一些，能够在你有时间的时候快点去找你。</p>]]></content>
    
    
    <categories>
      
      <category>YeahZH</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从杭州到上海再到杭州</title>
    <link href="/posts/7324.html"/>
    <url>/posts/7324.html</url>
    
    <content type="html"><![CDATA[<p>你说你找到了一个上海的工作，你说这份工作特别适合你。但地方远，而且都是在晚上工作。我其实心里非常不愿意你去，人生地不熟，一个人在上海。肯定会出现很多很多的问题，都要你一个一个独自应对，有时候我就在想，我要是也在上海该多好，住得离你很近，然后我肯定也非常乐意帮你。可我好像什么也干不了啊。干啥啥不行啊我。</p><p><img src="https://s1.ax1x.com/2023/02/16/pSbAIcq.jpg"></p><p>但最后你还是放下犹豫，去了那里。我真的觉得你是个很勇敢又很独立的女孩子，不对，你好像一直以来都是很勇敢很独立的女孩子。我觉得你刚到上海的那段时间肯定是有各种各样乱七八糟的事，你那时候不得事情安排的满满当当。虽然你对我只是一句简单的【还好】，但肯定还是很累的吧？</p><p><img src="https://s1.ax1x.com/2023/02/16/pSbAWNQ.jpg"></p><p>这份工作是意料之内的高强度的，你这本身睡眠质量就差，现在的工作强度又这么高，我真的挺担心你的，而且我设身处地地知道，睡得少，也太痛苦了！毕竟我有时候也会各种失眠，【失眠的时候各种想你哈哈哈经常半夜找你】</p><p><img src="https://s1.ax1x.com/2023/02/16/pSbALEF.jpg"></p><p>而且我心里一直有一个小愿望，就是来上海找一次你，我都多久没有见到你了，可那时候因为疫情，我一直都没有什么机会。而且因为上海疫情的严重程度，我也一直很担心你。后来你又听说，你可能要搬回杭州了，我真的也好为你高兴，然后我也可以离你又近了一些，你也可以回到这个熟悉的地方。</p><p><img src="https://s1.ax1x.com/2023/02/16/pSbAbHU.jpg"></p><p>可是老板一直一推再推，你我一度以为你们老板在画饼。后面又说一度gg…</p><p><img src="https://s1.ax1x.com/2023/02/16/pSbA49s.jpg"></p><p>后来貌似真的尘埃落定了？你们搬去了宝山，我也一度以为肯定是不会再搬来杭州了。毕竟刚搬到一个地方，怎么可能会在短时间内再搬呢。</p><p><img src="https://s1.ax1x.com/2023/02/16/pSbAHBT.jpg"></p><p>后来可能是不是你也认清了搬不回杭州的事实？拐了一只猫回家，哈哈哈这样也好，这样在这么大的城市里就会有猫猫陪着你了。</p><p><img src="https://s1.ax1x.com/2023/02/16/pSbA7uV.jpg"></p><p>最后竟然还有反转，我看到了你的微博，你的公司真的搬来杭州了！怎么会有这个drama的公司！你终于如愿以偿了，终于2回到杭州了！</p><p><img src="https://s1.ax1x.com/2023/02/16/pSbA53n.jpg"></p><p>还有我开心的是，从你开始毕业找工作，从杭州到上海再到杭州这一整段的时间经历，我都从你口中听到，不枉我一直以来对您的问东问西，这样就能让我对你有更多的了解了！但最遗憾的是，这一段经历，我啥也没参与，我也好想参与一些…可感觉你离我好远好远…</p>]]></content>
    
    
    <categories>
      
      <category>YeahZH</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我是真的不会算法啊</title>
    <link href="/posts/6b6cddb9.html"/>
    <url>/posts/6b6cddb9.html</url>
    
    <content type="html"><![CDATA[<h3 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h3><h4 id="1-对于一个2行N列的走道。现在用1x2或2x2的砖去铺满。问有多少种不同的方式（请用递推方式求解）。如果N很大，需要高精度计算。"><a href="#1-对于一个2行N列的走道。现在用1x2或2x2的砖去铺满。问有多少种不同的方式（请用递推方式求解）。如果N很大，需要高精度计算。" class="headerlink" title="1. 对于一个2行N列的走道。现在用1x2或2x2的砖去铺满。问有多少种不同的方式（请用递推方式求解）。如果N很大，需要高精度计算。"></a>1. 对于一个2行N列的走道。现在用1x2或2x2的砖去铺满。问有多少种不同的方式（请用递推方式求解）。如果N很大，需要高精度计算。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//（1）n=1，有1种方法，即1*2竖放</span><br><br><span class="hljs-comment">//（2）n=2，有3种方法</span><br><br><span class="hljs-comment">//（3）n&gt;=3，1*2竖放（占1列）有f(n-1)种方法，1*2横放（占2列）有f(n-2)种方法，2*2横放（占2列）有f(n-2)种方法，故：</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">pave</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pave</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-number">2</span> * <span class="hljs-built_in">pave</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n)<br>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-built_in">pave</span>(n) &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-在一个2-k×2-k-个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。"><a href="#2-在一个2-k×2-k-个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。" class="headerlink" title="2. 在一个2^k×2^k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。"></a>2. 在一个2^k×2^k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。</h4><p><img src="https://img-blog.csdnimg.cn/20200326114531158.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjY4NTcw,size_1,color_FFFFFF,t_70#pic_center"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;  <br><span class="hljs-type">int</span> g[N][N];  <br><span class="hljs-type">int</span> size,dx,dy;  <br><span class="hljs-type">int</span> title=<span class="hljs-number">1</span>;  <br><span class="hljs-comment">//左上角坐标、特殊骨牌坐标、长度  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">answer</span><span class="hljs-params">(<span class="hljs-type">int</span> lx,<span class="hljs-type">int</span> ly,<span class="hljs-type">int</span> dx,<span class="hljs-type">int</span> dy,<span class="hljs-type">int</span> size)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">if</span>(size==<span class="hljs-number">1</span>)  <br>    <span class="hljs-keyword">return</span>;  <br>    <span class="hljs-type">int</span> s=size/<span class="hljs-number">2</span>;  <br>    <span class="hljs-type">int</span> t=title++;  <br>    <span class="hljs-keyword">if</span>(dx&lt;lx+s&amp;&amp;dy&lt;ly+s) <span class="hljs-comment">//特殊坐标在左上角  </span><br>    &#123;  <br>        <span class="hljs-built_in">answer</span>(lx,ly,dx,dy,s);  <span class="hljs-comment">//在左上角分成四块继续递归</span><br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        g[lx+s<span class="hljs-number">-1</span>][ly+s<span class="hljs-number">-1</span>]=t;  <span class="hljs-comment">//如果不在左上角，则在该左上角区域的右下角填充</span><br>        <span class="hljs-built_in">answer</span>(lx,ly,lx+s<span class="hljs-number">-1</span>,ly+s<span class="hljs-number">-1</span>,s);  <span class="hljs-comment">//在左上角分成四块继续递归</span><br>    &#125;  <br>    <span class="hljs-keyword">if</span>(dx&lt;lx+s&amp;&amp;dy&gt;=ly+s)<span class="hljs-comment">//左下角  </span><br>    &#123;  <br>        <span class="hljs-built_in">answer</span>(lx,ly+s,dx,dy,s);  <span class="hljs-comment">//在左下角分成四块继续递归</span><br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        g[lx+s<span class="hljs-number">-1</span>][ly+s]=t;  <span class="hljs-comment">//如果不在左下角，则在该左下角区域的右上角填充</span><br>        <span class="hljs-built_in">answer</span>(lx,ly+s,lx+s<span class="hljs-number">-1</span>,ly+s,s);   <span class="hljs-comment">//在左下角分成四块继续递归</span><br>    &#125;  <br>    <span class="hljs-keyword">if</span>(dx&gt;=lx+s&amp;&amp;dy&lt;ly+s)  <span class="hljs-comment">//右上角</span><br>    &#123;  <br>        <span class="hljs-built_in">answer</span>(lx+s,ly,dx,dy,s);  <br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        g[lx+s][ly+s<span class="hljs-number">-1</span>]=t;  <br>        <span class="hljs-built_in">answer</span>(lx+s,ly,lx+s,ly+s<span class="hljs-number">-1</span>,s);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(dx&gt;=lx+s&amp;&amp;dy&gt;=ly+s)  <span class="hljs-comment">//右下角</span><br>    &#123;  <br>        <span class="hljs-built_in">answer</span>(lx+s,ly+s,dx,dy,s);  <br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        g[lx+s][ly+s]=t;  <br>        <span class="hljs-built_in">answer</span>(lx+s,ly+s,lx+s,ly+s,s);  <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-comment">//棋盘行数、特殊方格的行坐标、特殊方格的列坐标  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;size,&amp;dx,&amp;dy);  <br>    <span class="hljs-built_in">answer</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,dx,dy,size);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)  <br>    &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=size;j++)  <br>        &#123;  <br>   <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d &quot;</span>,g[i][j]);  <br>        &#125;  <br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="3-在n枚外观相同的硬币中，有一枚是假币，并且已知假币与真币的重量不同，已知道假币比真币轻。可以通过一架天平来任意比较两组硬币，设计一个高效的算法来检测这枚假币。要求用分治法称重来实现。"><a href="#3-在n枚外观相同的硬币中，有一枚是假币，并且已知假币与真币的重量不同，已知道假币比真币轻。可以通过一架天平来任意比较两组硬币，设计一个高效的算法来检测这枚假币。要求用分治法称重来实现。" class="headerlink" title="3. 在n枚外观相同的硬币中，有一枚是假币，并且已知假币与真币的重量不同，已知道假币比真币轻。可以通过一架天平来任意比较两组硬币，设计一个高效的算法来检测这枚假币。要求用分治法称重来实现。"></a>3. 在n枚外观相同的硬币中，有一枚是假币，并且已知假币与真币的重量不同，已知道假币比真币轻。可以通过一架天平来任意比较两组硬币，设计一个高效的算法来检测这枚假币。要求用分治法称重来实现。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CheckMoney</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> sum1=<span class="hljs-number">0</span>, sum2=<span class="hljs-number">0</span>, sum3=<span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> ((right-left+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)      <span class="hljs-comment">//偶数  </span><br>    &#123;  <br>        <span class="hljs-keyword">if</span> (left + <span class="hljs-number">1</span> == right)  <br>        &#123;  <br>            <span class="hljs-keyword">if</span> (arr[left] &lt; arr[right])  <br>            &#123;  <br>                <span class="hljs-keyword">return</span> left;  <br>            &#125;  <br>            <span class="hljs-keyword">else</span>  <br>                <span class="hljs-keyword">return</span> right;  <br>        &#125;  <br>        <span class="hljs-type">int</span> mid = (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>+left;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=left; i&lt;mid; ++i)  <br>        &#123;  <br>            sum1 += arr[i];  <br>            sum2 += arr[right – i +left];  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (sum1&lt;sum2)  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">CheckMoney</span>(arr, left, mid - <span class="hljs-number">1</span>);  <br>   <br>        &#125;  <br>        <span class="hljs-keyword">else</span>  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">CheckMoney</span>(arr, mid, right);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">else</span>    <span class="hljs-comment">//奇数</span><br>    &#123;  <br>        <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span>+left;  <br>   <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=left; i&lt;mid; ++i)  <br>        &#123;  <br>            sum1 += arr[i];  <br>            sum2 += arr[right - i+left];  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (sum1&lt;sum2)  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">CheckMoney</span>(arr, left, mid - <span class="hljs-number">1</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum1&gt;sum2)  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">CheckMoney</span>(arr, mid+<span class="hljs-number">1</span>, right);  <br>        &#125;  <br>        <span class="hljs-keyword">else</span>  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> mid;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>   <br>    <span class="hljs-type">int</span> arr[]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;  <br>    std::cout&lt;&lt;<span class="hljs-string">&quot;false coin positon &quot;</span> &lt;&lt; <span class="hljs-built_in">CheckMoney</span>(arr, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)+<span class="hljs-number">1</span>&lt;&lt;std::endl;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="4-组合学中有这样一个问题：某人给五个朋友写信，邀请他们来家中聚会。请柬和信封交由助手去处理。粗心的助手却把请柬全装错了信封。请问：助手会有多少种装错的可能呢？"><a href="#4-组合学中有这样一个问题：某人给五个朋友写信，邀请他们来家中聚会。请柬和信封交由助手去处理。粗心的助手却把请柬全装错了信封。请问：助手会有多少种装错的可能呢？" class="headerlink" title="4. 组合学中有这样一个问题：某人给五个朋友写信，邀请他们来家中聚会。请柬和信封交由助手去处理。粗心的助手却把请柬全装错了信封。请问：助手会有多少种装错的可能呢？"></a>4. 组合学中有这样一个问题：某人给五个朋友写信，邀请他们来家中聚会。请柬和信封交由助手去处理。粗心的助手却把请柬全装错了信封。请问：助手会有多少种装错的可能呢？</h4><p>$$<br>D_{n} &#x3D; (n-1)(D_{n-1}+D_{n-2})<br>$$</p><p>$$<br>D_{1}&#x3D;0,D_{2}&#x3D;1<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span>  </span><br>  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span><span class="hljs-comment">//一定要开long long  </span></span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">if</span>( x == <span class="hljs-number">1</span> )  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x == <span class="hljs-number">2</span> )  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-built_in">return</span> (x<span class="hljs-number">-1</span>)*(<span class="hljs-built_in">f</span>(x<span class="hljs-number">-1</span>)+<span class="hljs-built_in">f</span>(x<span class="hljs-number">-2</span>));  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> n;  <br>    cin&gt;&gt;n;  <br>    cout&lt;&lt;<span class="hljs-built_in">f</span>(n);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-设有-n-x3D-2-k-个运动员要进行网球循环赛。现要设计一个满足以下要求的比赛日程表："><a href="#5-设有-n-x3D-2-k-个运动员要进行网球循环赛。现要设计一个满足以下要求的比赛日程表：" class="headerlink" title="5.设有 n &#x3D; 2 ^ k 个运动员要进行网球循环赛。现要设计一个满足以下要求的比赛日程表："></a>5.设有 n &#x3D; 2 ^ k 个运动员要进行网球循环赛。现要设计一个满足以下要求的比赛日程表：</h4><p><strong>(1)每个选手必须与其他 n - 1 个选手各赛一次；</strong><br><strong>(2)每个选手一天只能参赛一次；</strong><br><strong>(3)循环赛在 n - 1 天内结束</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-type">int</span> **arr,<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>arr[x2+i][y2+j] = arr[x1+i][y1+j];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">table</span><span class="hljs-params">(<span class="hljs-type">int</span> **arr, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">table</span>(arr,x,y, n/<span class="hljs-number">2</span>);<br><span class="hljs-built_in">table</span>(arr,x+n/<span class="hljs-number">2</span>,y,n/<span class="hljs-number">2</span>);<br><span class="hljs-built_in">copy</span>(arr,x,y,x+n/<span class="hljs-number">2</span>,y+n/<span class="hljs-number">2</span>,n/<span class="hljs-number">2</span>);<br><span class="hljs-built_in">copy</span>(arr,x+n/<span class="hljs-number">2</span>,y,x,y+n/<span class="hljs-number">2</span>,n/<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> **arr, <span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>cout.<span class="hljs-built_in">width</span>(<span class="hljs-number">5</span>);<br>cout&lt;&lt;arr[i][j];<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> k;<br>cin&gt;&gt;k;<br><span class="hljs-type">int</span> n = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,k);<br><span class="hljs-type">int</span> **arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>arr[i]=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [n];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br><span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) arr[i][j]=i+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> arr[i][j]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">table</span>(arr,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n);<br><span class="hljs-built_in">print</span>(arr,n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h3><h4 id="1-双11到了，据说这2天会下红包雨，每个红包有不同的价值，小k好开心，但有个规则，就只能接掉落在他身旁的10米范围内的红包（0-10这11个位置）。小k想尽可能的多抢红包，这样就可以去买一个华为手机，小k每秒种只能在移动不超过一米的范围内接住红包。小k一开始站在5这个位置，因此在第一秒，他只能接到4-5-6这三个位置中其中一个位置上的红包。问小k最多可能接到多少价值的红包？"><a href="#1-双11到了，据说这2天会下红包雨，每个红包有不同的价值，小k好开心，但有个规则，就只能接掉落在他身旁的10米范围内的红包（0-10这11个位置）。小k想尽可能的多抢红包，这样就可以去买一个华为手机，小k每秒种只能在移动不超过一米的范围内接住红包。小k一开始站在5这个位置，因此在第一秒，他只能接到4-5-6这三个位置中其中一个位置上的红包。问小k最多可能接到多少价值的红包？" class="headerlink" title="1. 双11到了，据说这2天会下红包雨，每个红包有不同的价值，小k好开心，但有个规则，就只能接掉落在他身旁的10米范围内的红包（0-10这11个位置）。小k想尽可能的多抢红包，这样就可以去买一个华为手机，小k每秒种只能在移动不超过一米的范围内接住红包。小k一开始站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的红包。问小k最多可能接到多少价值的红包？"></a>1. 双11到了，据说这2天会下红包雨，每个红包有不同的价值，小k好开心，但有个规则，就只能接掉落在他身旁的10米范围内的红包（0-10这11个位置）。小k想尽可能的多抢红包，这样就可以去买一个华为手机，小k每秒种只能在移动不超过一米的范围内接住红包。小k一开始站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的红包。问小k最多可能接到多少价值的红包？</h4><p><strong>Input</strong><br><strong>第一行输入整数n，表示共有多少个红包，n&lt;1000；</strong><br><strong>后面n行表示n个红包，每行有三个整数，分别表示红包掉落的位置、时间和价值。</strong></p><p>状态转移方程为：<br>$$<br>dp[i][j]&#x3D;max(dp[i+1][j-1]，dp[i+1][j]，dp[i+1][j+1]) + dp[i][j]<br>$$</p><p>其中，$d[i][j]$ 表示i时刻j位置开始出发，到最终时间点所获得的最大红包数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-type">int</span> dp[<span class="hljs-number">1010</span>][<span class="hljs-number">12</span>];  <span class="hljs-comment">// dp[i][j]表示i时刻j位置开始出发，到最终时间点所获得的最大红包数   </span><br>  <br><span class="hljs-comment">//两个数中的最大值  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max_2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">return</span> (a&gt;b) ? a :b;  <br>&#125;   <br>  <br><span class="hljs-comment">//三个数中的最大值  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxn</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> max = (a&gt;b) ? a : b;  <br>    <span class="hljs-keyword">return</span> (max&gt;c) ? max : c;  <br>&#125;   <br>  <br><span class="hljs-comment">// 计算最优值  </span><br><span class="hljs-comment">// 状态转移方程为：dp[i][j]=maxn(dp[i+1][j-1]，dp[i+1][j]，dp[i+1][j+1]) + dp[i][j]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span> max_time)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=max_time<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">11</span>; j++)&#123;  <br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)  <span class="hljs-comment">// 在第0位置，下一秒只能原地或向右移动   </span><br>                dp[i][j] = <span class="hljs-built_in">max_2</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) + dp[i][j];  <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">10</span>)   <span class="hljs-comment">// 在第10位置，下一秒只能原地或向左移动   </span><br>                dp[i][j] = <span class="hljs-built_in">max_2</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]) + dp[i][j];  <br>            <span class="hljs-keyword">else</span>  <br>                dp[i][j] = <span class="hljs-built_in">maxn</span>(dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>],dp[i+<span class="hljs-number">1</span>][j],dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])+ dp[i][j];  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> n;  <br>    cin &gt;&gt; n;  <br>    <span class="hljs-type">int</span> location, time, value;  <br>    <span class="hljs-type">int</span> max_time = <span class="hljs-number">-1</span>;  <br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));  <br>    <span class="hljs-comment">// 保存输入的数据到数组中   </span><br>    <span class="hljs-keyword">while</span>(n--)&#123;  <br>        cin &gt;&gt; location &gt;&gt; time &gt;&gt; value;  <br>        dp[time][location] = value;  <br>        <span class="hljs-keyword">if</span>(time &gt; max_time) max_time = time;  <br>    &#125;   <br>    <span class="hljs-built_in">maxValue</span>(max_time);  <br>    cout &lt;&lt; dp[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] &lt;&lt; endl;  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="2-给出长度为n的数组，求最大连续子段和，-输出该最大和。"><a href="#2-给出长度为n的数组，求最大连续子段和，-输出该最大和。" class="headerlink" title="2. 给出长度为n的数组，求最大连续子段和， 输出该最大和。"></a>2. 给出长度为n的数组，求最大连续子段和， 输出该最大和。</h4><p><strong>Input</strong><br><strong>第1行输入一个整数n&lt;50；表示输入数组的大小</strong><br><strong>第2行输入n个数，中间用空格隔开</strong></p><p>状态转移方程为：</p><p>$$nums[i]=\left\{\begin{matrix} nums[i], nums[i-1]<=0\\nums[i]+nums[i-1],nums[i-1]>0\end{matrix}\right.$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, nums[<span class="hljs-number">51</span>];  <br>    <span class="hljs-type">int</span> max;<br>    cin &gt;&gt; n;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)  <br>        cin &gt;&gt; nums[i];  <br>    max = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//初始令最大值为第一个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;  <br>        <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//判断到前一个数为止的最大子序列和是否大于0</span><br>            nums[i] += nums[i - <span class="hljs-number">1</span>];<span class="hljs-comment">//若大于0，则继续扩大子序列</span><br>        <span class="hljs-keyword">if</span> (max &lt; nums[i])<br>            max = nums[i];<span class="hljs-comment">//更新最大值</span><br>    &#125;  <br>    cout &lt;&lt; max &lt;&lt; endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="3-小K是个苦命的孩子，他的师傅为了多赚钱，以减肥为理由，让他去采药，并说不完成不能吃饭。野地里有许多不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。要求在规定的时间t里，采到的草药的总价值最大。"><a href="#3-小K是个苦命的孩子，他的师傅为了多赚钱，以减肥为理由，让他去采药，并说不完成不能吃饭。野地里有许多不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。要求在规定的时间t里，采到的草药的总价值最大。" class="headerlink" title="3. 小K是个苦命的孩子，他的师傅为了多赚钱，以减肥为理由，让他去采药，并说不完成不能吃饭。野地里有许多不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。要求在规定的时间t里，采到的草药的总价值最大。"></a>3. 小K是个苦命的孩子，他的师傅为了多赚钱，以减肥为理由，让他去采药，并说不完成不能吃饭。野地里有许多不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。要求在规定的时间t里，采到的草药的总价值最大。</h4><p><strong>Input</strong><br><strong>第一行有2个整数T(1≤T≤1000)和M(1≤M≤100)，一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。</strong><br><strong>接下来的M行每行包括两个在1到100之间包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</strong></p><p>状态转移方程为：<br>$$<br>dp[j]&#x3D;max(dp[j-c[i]]+w[i],dp[j])<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1005</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br><span class="hljs-type">int</span> dp[maxn], w[maxn], c[maxn];  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> t, m;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;t, &amp;m);   <span class="hljs-comment">//输入总的采摘时间和草药数目</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;c[i], &amp;w[i]);    <span class="hljs-comment">//分别输入每株草药的时间和价值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)  <span class="hljs-comment">//先遍历草药（物品），后遍历时间（背包）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = t; j &gt;= c[i]; j--)  <span class="hljs-comment">//一维数组dp倒序保证物品只被添加一次，二维数组可以正序也可以倒序，一层一层分离肯定不会重复添加</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j - c[i]] + w[i], dp[j]);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[t]);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="4-给定两个字符串，求解这两个字符串的最长非连续（允许连续或非连续）的公共子序列的长度（Longest-Common-Sequence）。"><a href="#4-给定两个字符串，求解这两个字符串的最长非连续（允许连续或非连续）的公共子序列的长度（Longest-Common-Sequence）。" class="headerlink" title="4. 给定两个字符串，求解这两个字符串的最长非连续（允许连续或非连续）的公共子序列的长度（Longest Common Sequence）。"></a>4. 给定两个字符串，求解这两个字符串的最长非连续（允许连续或非连续）的公共子序列的长度（Longest Common Sequence）。</h4><p>比如字符串1：BDCABA；字符串2：ABCBDAB。<br>则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA<br><strong>Input</strong><br>输入2行，每行一个字符串；字符串长度&lt;1000。</p><p>状态转移方程为：</p><p>$$dp[i][j]=\left\{\begin{matrix} dp[i-1][j-1]+1, s1[i-1]==s2[j-1]\\max(dp[i-1][j],dp[i][j-1]),s1[i-1]!=s2[j-1]\end{matrix}\right.$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>] = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">//记录动态规划结果</span><br>string s1, s2;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLCS</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">length</span>(), m = s2.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j++) &#123;<br>            <span class="hljs-keyword">if</span> (s1[i - <span class="hljs-number">1</span>] == s2[j - <span class="hljs-number">1</span>]) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">//若当前两个指针指向的字符相等,在斜对角的基础上加1</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//若当前两个指针指向的字符不相等,则在两边找一个最大值</span><br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<span class="hljs-comment">//解两个子问题</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; s1 &gt;&gt; s2;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">findLCS</span>();<br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-一家公司购买长钢条，将其切割成短钢条出售，切割本身没有成本，长度为i的短钢条的价格为Pi。那给定一段长度为n的钢条和一个价格表Pi-求钢条的切割方案使得收益Rn最大。"><a href="#5-一家公司购买长钢条，将其切割成短钢条出售，切割本身没有成本，长度为i的短钢条的价格为Pi。那给定一段长度为n的钢条和一个价格表Pi-求钢条的切割方案使得收益Rn最大。" class="headerlink" title="5. 一家公司购买长钢条，将其切割成短钢条出售，切割本身没有成本，长度为i的短钢条的价格为Pi。那给定一段长度为n的钢条和一个价格表Pi,求钢条的切割方案使得收益Rn最大。"></a>5. 一家公司购买长钢条，将其切割成短钢条出售，切割本身没有成本，长度为i的短钢条的价格为Pi。那给定一段长度为n的钢条和一个价格表Pi,求钢条的切割方案使得收益Rn最大。</h4><p>状态转移方程为：<br>$$<br>dp[i] &#x3D; max(dp[i],dp[i-j]+steel[j])<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> steel_len;<span class="hljs-comment">//钢条原始长度，也是钢条种类的数量</span><br><span class="hljs-type">int</span> steel[<span class="hljs-number">11</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">17</span>,<span class="hljs-number">17</span>,<span class="hljs-number">20</span>,<span class="hljs-number">24</span>,<span class="hljs-number">30</span> &#125;; <span class="hljs-comment">//记录已知长度钢条价值</span><br><span class="hljs-comment">//动规解法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-type">int</span>* arr_dp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[len + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(arr_dp, <span class="hljs-number">0</span>, (len + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//初始化为0</span><br>    <span class="hljs-comment">//对于dp表的每一项（钢条总长度）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>        <span class="hljs-comment">//首段长度j</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>            arr_dp[i] = <span class="hljs-built_in">max</span>(arr_dp[i], steel[j] + arr_dp[i - j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr_dp[len];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; steel_len;<br>    cout &lt;&lt; <span class="hljs-built_in">dp</span>(steel_len) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-一条街上有N个商铺；商铺i有价值V-i-的物品，你有足够的时间在晚上光顾所有的商店，人们称呼你为盗贼；每个商店都有一个报警器，会在晚上报警，但是只有相邻的2个商店同时报警时，警察才会出动；你需要证明你是个合格的盗贼。输出偷盗的最大价值。"><a href="#6-一条街上有N个商铺；商铺i有价值V-i-的物品，你有足够的时间在晚上光顾所有的商店，人们称呼你为盗贼；每个商店都有一个报警器，会在晚上报警，但是只有相邻的2个商店同时报警时，警察才会出动；你需要证明你是个合格的盗贼。输出偷盗的最大价值。" class="headerlink" title="6. 一条街上有N个商铺；商铺i有价值V[i]的物品，你有足够的时间在晚上光顾所有的商店，人们称呼你为盗贼；每个商店都有一个报警器，会在晚上报警，但是只有相邻的2个商店同时报警时，警察才会出动；你需要证明你是个合格的盗贼。输出偷盗的最大价值。"></a>6. 一条街上有N个商铺；商铺i有价值V[i]的物品，你有足够的时间在晚上光顾所有的商店，人们称呼你为盗贼；每个商店都有一个报警器，会在晚上报警，但是只有相邻的2个商店同时报警时，警察才会出动；你需要证明你是个合格的盗贼。输出偷盗的最大价值。</h4><p><strong>Input</strong></p><p>第一行一个整数N&lt;&#x3D;100，商店数。</p><p>第二行N个整数，每个商店的价值。</p><p>状态转移方程为：<br>$$<br>dp[i-1]&#x3D;max(dp[i-2],dp[i-3]+dp[i-1])<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++) &#123;<br>        dp[i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">3</span>] + dp[i - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 动态规划递推关系</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        cin &gt;&gt; dp[i];<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">findMaxValue</span>(n);<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、贪心"><a href="#三、贪心" class="headerlink" title="三、贪心"></a>三、贪心</h3><h4 id="1-小K没事干，他要搬砖头，为了达到较好的减肥效果，教练规定的方式很特别：每一次，小K可以把两堆砖头合并到一起，消耗的体力等于两堆砖头的重量之和。经过-n-1次合并后，-就只剩下一堆了。小K在搬砖头时总共消耗的体力等于每次合并所耗体力之和。小K为了偷懒，希望耗费的体力最小。"><a href="#1-小K没事干，他要搬砖头，为了达到较好的减肥效果，教练规定的方式很特别：每一次，小K可以把两堆砖头合并到一起，消耗的体力等于两堆砖头的重量之和。经过-n-1次合并后，-就只剩下一堆了。小K在搬砖头时总共消耗的体力等于每次合并所耗体力之和。小K为了偷懒，希望耗费的体力最小。" class="headerlink" title="1. 小K没事干，他要搬砖头，为了达到较好的减肥效果，教练规定的方式很特别：每一次，小K可以把两堆砖头合并到一起，消耗的体力等于两堆砖头的重量之和。经过 n-1次合并后， 就只剩下一堆了。小K在搬砖头时总共消耗的体力等于每次合并所耗体力之和。小K为了偷懒，希望耗费的体力最小。"></a>1. 小K没事干，他要搬砖头，为了达到较好的减肥效果，教练规定的方式很特别：每一次，小K可以把两堆砖头合并到一起，消耗的体力等于两堆砖头的重量之和。经过 n-1次合并后， 就只剩下一堆了。小K在搬砖头时总共消耗的体力等于每次合并所耗体力之和。小K为了偷懒，希望耗费的体力最小。</h4><p>例如有 3堆砖头，数目依次为 1、2、9 。可以先将 1 、 2 堆合并，新堆数目为3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为12 。所以总共耗费体力 &#x3D;3+12&#x3D;15。可以证明 15为最小的体力耗费值。</p><p><strong>Input</strong><br>共两行。</p><p>第一行是一个整数 n(1≤n≤1000) ，表示砖头堆数。</p><p>第二行n个整数，每个整数表示每堆砖头的砖头块数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">1000</span>],sum=<span class="hljs-number">0</span>,i;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(a, a + n);<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-type">int</span> temp = a[i + <span class="hljs-number">1</span>] + a[i];<span class="hljs-comment">//记录前两个最小的值</span><br><span class="hljs-type">int</span> k = i + <span class="hljs-number">2</span>;<span class="hljs-comment">//k为第三个的下标</span><br><span class="hljs-keyword">while</span> (a[k] &lt; temp &amp;&amp; k &lt; n) &#123;<span class="hljs-comment">//比较第三个和前两个的和，若第三个比前两个要小</span><br>a[k - <span class="hljs-number">1</span>] = a[k];<span class="hljs-comment">//把第三个值前移，</span><br>k++;  <span class="hljs-comment">//一直循环，直到后面比两个最小值的和小的数都移到前面</span><br>&#125;<br>a[k - <span class="hljs-number">1</span>] = temp; <br>sum += temp;<br><br>&#125;<br>cout &lt;&lt; sum &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-给定一个非负整数数组，假定你的初始位置为数组第一个位置。数组中的每个元素代表你在那个位置能够跳跃的最大长度。你的目标是到达最后一个下标位置，并且使用最少的跳跃次数。"><a href="#2-给定一个非负整数数组，假定你的初始位置为数组第一个位置。数组中的每个元素代表你在那个位置能够跳跃的最大长度。你的目标是到达最后一个下标位置，并且使用最少的跳跃次数。" class="headerlink" title="2. 给定一个非负整数数组，假定你的初始位置为数组第一个位置。数组中的每个元素代表你在那个位置能够跳跃的最大长度。你的目标是到达最后一个下标位置，并且使用最少的跳跃次数。"></a>2. 给定一个非负整数数组，假定你的初始位置为数组第一个位置。数组中的每个元素代表你在那个位置能够跳跃的最大长度。你的目标是到达最后一个下标位置，并且使用最少的跳跃次数。</h4><p><strong>Input</strong></p><p>输入一组非负整数数组，数组长度不超过500。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curDistance = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前覆盖最远距离下标</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 记录走的最大步数</span><br>        <span class="hljs-type">int</span> nextDistance = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 下一步覆盖最远距离下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            nextDistance = <span class="hljs-built_in">max</span>(nums[i] + i, nextDistance);  <span class="hljs-comment">// 更新下一步覆盖最远距离下标</span><br>            <span class="hljs-keyword">if</span> (i == curDistance) &#123;                         <span class="hljs-comment">// 遇到当前覆盖最远距离下标</span><br>                <span class="hljs-keyword">if</span> (curDistance &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;       <span class="hljs-comment">// 如果当前覆盖最远距离下标不是终点</span><br>                    ans++;                                  <span class="hljs-comment">// 需要走下一步</span><br>                    curDistance = nextDistance;             <span class="hljs-comment">// 更新当前覆盖最远距离下标（相当于加油了）</span><br>                    <span class="hljs-keyword">if</span> (nextDistance &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 下一步的覆盖范围已经可以达到终点，结束循环</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;                               <span class="hljs-comment">// 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> curDistance = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前覆盖的最远距离下标</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 记录走的最大步数</span><br>        <span class="hljs-type">int</span> nextDistance = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 下一步覆盖的最远距离下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 注意这里是小于nums.size() - 1，这是关键所在</span><br>            nextDistance = <span class="hljs-built_in">max</span>(nums[i] + i, nextDistance); <span class="hljs-comment">// 更新下一步覆盖的最远距离下标</span><br>            <span class="hljs-keyword">if</span> (i == curDistance) &#123;                 <span class="hljs-comment">// 遇到当前覆盖的最远距离下标</span><br>                curDistance = nextDistance;         <span class="hljs-comment">// 更新当前覆盖的最远距离下标</span><br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3-给出n个区间的起点和终点，求最少使用其中多少个区间可以将所有区间所在的区域完全覆盖。（测试的数据确保这1点）。"><a href="#3-给出n个区间的起点和终点，求最少使用其中多少个区间可以将所有区间所在的区域完全覆盖。（测试的数据确保这1点）。" class="headerlink" title="3. 给出n个区间的起点和终点，求最少使用其中多少个区间可以将所有区间所在的区域完全覆盖。（测试的数据确保这1点）。"></a>3. 给出n个区间的起点和终点，求最少使用其中多少个区间可以将所有区间所在的区域完全覆盖。（测试的数据确保这1点）。</h4><p><strong>Input</strong></p><p>第1行一个整数n，表示n个区间；</p><p>第2行开始n行，每行2个整数，表示一个区间范围。</p><p>类似[1,4][5,6]被认为是覆盖了[1,6]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//先按开始点升序，结束点升序将数据排序。为了使覆盖总区间的所需的子区间数最少，就要选出一系列覆盖范围最广的子区间</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">part</span><span class="hljs-comment">//区间两端</span><br>&#123;<br>    <span class="hljs-type">int</span> star1, end1;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(part s1, part s2)</span> </span>&#123; <span class="hljs-comment">// 自定义排序方式1、开始点升序，2、结束点升序</span><br>    <span class="hljs-keyword">if</span> (s1.star1 &lt; s2.star1)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s1.star1 == s2.star1 &amp;&amp; s1.end1 &lt; s2.end1)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    part a[<span class="hljs-number">100</span>];<span class="hljs-comment">//全部待选区间</span><br>    part r[<span class="hljs-number">100</span>];<br>    <span class="hljs-comment">//在a中选好的数放入r中</span><br> <br>    <span class="hljs-type">int</span> n, index = <span class="hljs-number">0</span>, i;<br> <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i].star1 &gt;&gt; a[i].end1;<br>    &#125;<br> <br>    <span class="hljs-built_in">sort</span>(a, a + n, cmp);<br> <br>    <span class="hljs-type">int</span> right = a[<span class="hljs-number">0</span>].star1 - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = a[n - <span class="hljs-number">1</span>].end1; <span class="hljs-comment">// 待覆盖区间最远处</span><br> <br> <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; )<br>    &#123;<br>        <span class="hljs-type">int</span> maRight = a[i].end1, maIndex = i;<br> <br> <br>        <span class="hljs-keyword">while</span> (a[i].star1 &lt;= right + <span class="hljs-number">1</span> &amp;&amp; i &lt; n) &#123; <span class="hljs-comment">// 寻找最远子区间</span><br>            <span class="hljs-keyword">if</span> (a[i].end1 &gt; maRight) &#123;<br>                maRight = a[i].end1;<br>                maIndex = i;<br>            &#125;<br>            i++;  <span class="hljs-comment">//比较完数组往后移</span><br>        &#125;<br>        right = maRight;<br>        r[index++] = a[maIndex];<br>        i = maIndex;<br>        <span class="hljs-keyword">if</span> (right == end)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>        cout &lt;&lt; r[i].star1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r[i].end1 &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-一条街的一边有几座房子。因为环保原因居民想要在路边种些树，路边的地区被分割成块，并被编号成1-N；每个部分为一个单位尺寸大小并最多可种一棵树，每个居民想在门前种些树并指定了三个号码B-E-T，这三个数表示该居民想在B和E之间最少种T棵树。当然，B≤E-居民必须记住在指定区不能种多于区域地块数的树，所以T≤E-B-l。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。"><a href="#4-一条街的一边有几座房子。因为环保原因居民想要在路边种些树，路边的地区被分割成块，并被编号成1-N；每个部分为一个单位尺寸大小并最多可种一棵树，每个居民想在门前种些树并指定了三个号码B-E-T，这三个数表示该居民想在B和E之间最少种T棵树。当然，B≤E-居民必须记住在指定区不能种多于区域地块数的树，所以T≤E-B-l。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。" class="headerlink" title="4. 一条街的一边有几座房子。因为环保原因居民想要在路边种些树，路边的地区被分割成块，并被编号成1..N；每个部分为一个单位尺寸大小并最多可种一棵树，每个居民想在门前种些树并指定了三个号码B,E,T，这三个数表示该居民想在B和E之间最少种T棵树。当然，B≤E,居民必须记住在指定区不能种多于区域地块数的树，所以T≤E-B+l。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。"></a>4. 一条街的一边有几座房子。因为环保原因居民想要在路边种些树，路边的地区被分割成块，并被编号成1..N；每个部分为一个单位尺寸大小并最多可种一棵树，每个居民想在门前种些树并指定了三个号码B,E,T，这三个数表示该居民想在B和E之间最少种T棵树。当然，B≤E,居民必须记住在指定区不能种多于区域地块数的树，所以T≤E-B+l。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。</h4><p><strong>Input</strong></p><p>第一行包含数据N，区域的个数；</p><p>第二行包含H，房子的数目；</p><p>下面的H行描述居民们的需要:B E T。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-type">int</span> n, m, k, ans;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> <span class="hljs-comment">// 保存要求数据</span><br>&#123;<br>    <span class="hljs-type">int</span> b, e, t;<br>&#125;a[<span class="hljs-number">5005</span>];<br><span class="hljs-type">bool</span> used[<span class="hljs-number">30005</span>]; <span class="hljs-comment">// 记录该位置是否种过树</span><br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> node&amp; a, <span class="hljs-type">const</span> node&amp; b)</span> <span class="hljs-comment">// 自定义排序方式</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.e &lt; b.e;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) <span class="hljs-comment">// 输入数据</span><br>    &#123;<br>        cin &gt;&gt; a[i].b &gt;&gt; a[i].e &gt;&gt; a[i].t;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a, a + m, cmp);<br>    <span class="hljs-built_in">memset</span>(used, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(used)); <span class="hljs-comment">//初始化每个位置都没种过树</span><br>    ans = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录所需树的数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)<br>    &#123;<br>        k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = a[i].b;j &lt;= a[i].e;j++) <span class="hljs-comment">// 求在该要求区间内已经种了多少树</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (used[j]) k++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt;= a[i].t) <span class="hljs-comment">// 达到要求</span><br>            <span class="hljs-keyword">continue</span>;<br>        k = a[i].t - k;  <span class="hljs-comment">// 还要种的数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = a[i].e;j &gt;= a[i].b;j--) <span class="hljs-comment">//从后往前种</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (used[j] == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 寻找没种过的位置</span><br>            &#123;<br>                used[j] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//种树</span><br>                ans++;<br>                k--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、搜索"><a href="#四、搜索" class="headerlink" title="四、搜索"></a>四、搜索</h3><h4 id="1-有一个由数字-0、1-组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1-包围构成，每个节点只能走上下左右-4-个方向。现要求把封闭区域内的所有空间都填写成2。"><a href="#1-有一个由数字-0、1-组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1-包围构成，每个节点只能走上下左右-4-个方向。现要求把封闭区域内的所有空间都填写成2。" class="headerlink" title="1. 有一个由数字 0、1 组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1 包围构成，每个节点只能走上下左右 4 个方向。现要求把封闭区域内的所有空间都填写成2。"></a>1. 有一个由数字 0、1 组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1 包围构成，每个节点只能走上下左右 4 个方向。现要求把封闭区域内的所有空间都填写成2。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> mp[maxn][maxn], vis[maxn][maxn], n;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt; n - <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">0</span> || y &gt; n - <span class="hljs-number">1</span> || vis[x][y] || mp[x][y] != <span class="hljs-number">0</span>)  <span class="hljs-comment">//走到头了被封住了</span><br>        <span class="hljs-keyword">return</span>;<br>    vis[x][y] = <span class="hljs-number">1</span>;  <span class="hljs-comment">//如果不是边界，且没有访问过，且map[x][y]为0，走得通，标个1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)  <span class="hljs-comment">//四个方位都跑一跑</span><br>        <span class="hljs-built_in">dfs</span>(x + dir[i][<span class="hljs-number">0</span>], y + dir[i][<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mp[i][j]);<br>            vis[i][j] = mp[i][j];<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, i), <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, i), <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>), <span class="hljs-built_in">dfs</span>(i, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, vis[i][j] ? mp[i][j] : <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-有一个由数字-0、1-组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1-包围构成，每个节点只能走上下左右-4-个方向。现要求只把【最大封闭区域】内的空间填写成2-。"><a href="#2-有一个由数字-0、1-组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1-包围构成，每个节点只能走上下左右-4-个方向。现要求只把【最大封闭区域】内的空间填写成2-。" class="headerlink" title="2. 有一个由数字 0、1 组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1 包围构成，每个节点只能走上下左右 4 个方向。现要求只把【最大封闭区域】内的空间填写成2 。"></a>2. 有一个由数字 0、1 组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1 包围构成，每个节点只能走上下左右 4 个方向。现要求只把【最大封闭区域】内的空间填写成2 。</h4><p><strong>Input</strong></p><p>每组测试数据第一行一个整数 n(1≤n≤30)</p><p>接下来 n 行，由 0 和 1 组成的 n×n 的方阵。</p><p>封闭区域内至少有一个0，测试数据保证最大区域只有一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> mp[maxn][maxn], n, idx = <span class="hljs-number">2</span>, num = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt; n - <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">0</span> || y &gt; n - <span class="hljs-number">1</span> || mp[x][y] != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    mp[x][y] = idx;<br>    num++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">dfs</span>(x + dir[i][<span class="hljs-number">0</span>], y + dir[i][<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mp[i][j]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>), <span class="hljs-built_in">dfs</span>(i, n - <span class="hljs-number">1</span>), <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, i), <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span> (!mp[i][j])<br>            &#123;<br>                num = <span class="hljs-number">0</span>;<br>                idx++;<br>                <span class="hljs-built_in">dfs</span>(i, j);<br>                <span class="hljs-keyword">if</span> (num &gt; mx)<br>                &#123;<br>                    ans = idx;<br>                    mx = num;<br>                &#125;<br>            &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, mp[i][j] == ans ? <span class="hljs-number">2</span> : (mp[i][j] == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-给定图G-x3D-V-E-，需要为图G的各顶点着色，是否有一种着色法使G中相邻的两个顶点有不同的颜色"><a href="#3-给定图G-x3D-V-E-，需要为图G的各顶点着色，是否有一种着色法使G中相邻的两个顶点有不同的颜色" class="headerlink" title="3. 给定图G&#x3D;(V, E)，需要为图G的各顶点着色，是否有一种着色法使G中相邻的两个顶点有不同的颜色?"></a>3. 给定图G&#x3D;(V, E)，需要为图G的各顶点着色，是否有一种着色法使G中相邻的两个顶点有不同的颜色?</h4><p><strong>Input</strong></p><p>第一行是顶点的个数n（2≤n≤8），颜色数m（1≤m≤n）。</p><p>接下来是顶点之间的连接关系：a b；表示a和b相邻。顶点从1开始计。</p><p>当a，b同时为0时表示输入结束。</p><p><strong>输出着色方案总数和最少颜色数。如果无可行方案，颜色数为0。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">G</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> a[maxn], n, m, ans, mn = inf;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[x].<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[x] == a[G[x][i]])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt; n)<br>    &#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            s.<span class="hljs-built_in">insert</span>(a[i]);<br>        mn = <span class="hljs-built_in">min</span>(mn, <span class="hljs-built_in">int</span>(s.<span class="hljs-built_in">size</span>()));<br>        ans++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        a[x] = i;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(x))<br>            <span class="hljs-built_in">solve</span>(x + <span class="hljs-number">1</span>);<br>        a[x] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        G[x].<span class="hljs-built_in">push_back</span>(y);<br>        G[y].<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, ans, mn == inf ? <span class="hljs-number">0</span> : mn);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-N皇后的排列，每行一个不冲突；N-lt-x3D-13。"><a href="#4-N皇后的排列，每行一个不冲突；N-lt-x3D-13。" class="headerlink" title="4. N皇后的排列，每行一个不冲突；N&lt;&#x3D;13。"></a>4. N皇后的排列，每行一个不冲突；N&lt;&#x3D;13。</h4><p><strong>输入要求</strong><br>一个数字N (6 &lt;&#x3D; N &lt;&#x3D; 13) 表示棋盘是N x N大小的。</p><p><strong>输出要求</strong><br>前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。<br>解的输出顺序为从上到下从左到右，小的优先输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> q[<span class="hljs-number">15</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queen</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> j;<br><span class="hljs-type">int</span> col,flag;<br><br><br><span class="hljs-keyword">if</span>(i==n+<span class="hljs-number">1</span>)<span class="hljs-comment">//所有的行全部走完，即成功找到一种解法</span><br>    &#123;<span class="hljs-comment">//注意是n+1因为只有到n+1才说明前n行都ok</span><br>            sum++;<br><br>            <span class="hljs-keyword">if</span>(sum&lt;=<span class="hljs-number">3</span>)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>                &#123;<span class="hljs-keyword">if</span>(j==n)<br>                       cout&lt;&lt;q[j]&lt;&lt;endl;<br>                    <span class="hljs-keyword">else</span><br>                        cout&lt;&lt;q[j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>            &#125;<br>                <span class="hljs-keyword">return</span> ;<br>    &#125;<br><span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(col=<span class="hljs-number">1</span>;col&lt;=n;col++)<span class="hljs-comment">//遍历i行的每一列,检查有没有可以的</span><br>        &#123;<br>            flag=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;i;j++)<span class="hljs-comment">//遍历前i行是否符合</span><br>                &#123;<span class="hljs-keyword">if</span>(col==q[j]||i-col==j-q[j]||i+col==j+q[j])<br>                    &#123;<br>                    <span class="hljs-comment">//前面几行中已经在这一列有皇后了</span><br>                    <span class="hljs-comment">//在主对角线中，其行与列的差相同即i-col==j-q[j]</span><br>                    <span class="hljs-comment">//在副对角线中，其行与列的和相同即i+col==j+q[j]</span><br>                    flag=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>                &#123;<br>                q[i]=col;<br>                <span class="hljs-built_in">queen</span>(i+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-built_in">memset</span>(q,<span class="hljs-number">15</span>,<span class="hljs-built_in">sizeof</span>(q));<span class="hljs-comment">//q数组即皇后所在的列的位置，q[j]即皇后位于第j行第q[j]列</span><br><span class="hljs-built_in">queen</span>(<span class="hljs-number">1</span>);<br>cout&lt;&lt;sum&lt;&lt;endl;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>想去你生活的地方看看</title>
    <link href="/posts/64429.html"/>
    <url>/posts/64429.html</url>
    
    <content type="html"><![CDATA[<p>心情不愉快的时候，还是比较喜欢一个人到处逛逛的，但我最想去的，还是你有过生活，有经历的地方，因为知道那些路你肯定得有走过，就会有很不一样的感觉。首先最想要去的，当然就是景宁啦，大家伙口中的景宁到底是什么样的呢，真的很好奇。我还一直记得，你曾经骑着车从家到图书馆，边骑车还边和我说话，我也想去看一看。而且我之前貌似有一些些印象你的家是石印山小区？好久好久以前你好像给我发过定位，如果我记错了当我没有说哈哈哈哈。</p><p><img src="https://s1.ax1x.com/2023/02/16/pSHj1Sg.jpg"></p><blockquote><p>一定要在这里买一杯古茗，证明我来过。</p></blockquote><p><img src="https://s1.ax1x.com/2023/02/16/pSHjGOs.jpg"></p><blockquote><p>你说你们要是约好去哪里玩，会不会先在这里集合。</p></blockquote><p><img src="https://s1.ax1x.com/2023/02/16/pSHj3lQ.jpg"></p><blockquote><p>这条路好长好长，我从头到尾走了一遍。</p></blockquote><p><img src="https://s1.ax1x.com/2023/02/16/pSHj8yj.jpg"></p><blockquote><p>你就说这是不是你家门口啊，要是知道具体在哪儿一定拜访叔叔阿姨。</p></blockquote><p>之前我也去过你的大学，还好那是疫情前的时候，学校还可以放我进去，要是放到现在，那我可就太可惜了，那我就再也进不去了！那多亏啊，你的大学四年我连你的大学校门都没进去过，虽然你不知道。我进去就想找你所在的学院在哪儿，去找你平时上课的地方，好像虽然门都关着。我要是自己能力再高些，能够和你在同一所大学该多好啊。这样就有很多很多陪你当面说说话的机会，就可能很多很多都变了…</p><p><img src="https://s1.ax1x.com/2023/02/16/pSHjakV.jpg"></p><p><img src="https://s1.ax1x.com/2023/02/16/pSHjYmn.jpg"></p><p>可能去过这些地方，能让我能再了解你一些？</p>]]></content>
    
    
    <categories>
      
      <category>YeahZH</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>你我的未来，会是什么样子？</title>
    <link href="/posts/25410d34.html"/>
    <url>/posts/25410d34.html</url>
    
    <content type="html"><![CDATA[<p>3月25日 20:35 分，天气晴，我终于鼓起勇气，给你发了一条微信。</p><p><img src="/img/chat1.jpg"></p><p>好开心啊，感觉心里又有了那么一点儿动力~啊，不是一点儿，很多很多的动力！</p><p><img src="/img/chat2.jpg"></p><p>你说你不想再学计算机了，不想再搞互联网了，不想再熬夜了……我记得以前的你，好像对计算机这一方向有一种特别的憧憬的呀，现在怎么变成这个样子了，怕是被杭师大计算机系磨平了棱角哈哈哈？原本熬夜的第一名的叶芷含现在也会讨厌熬夜，害怕猝死了哈哈哈。</p><p>你说你想当一个老师，还要去跨考数学方向的研究生，你也太厉害了哇，一个学计算机的要和学四年数学的同台竞争，但我永远相信你，永远支持你，放手去冲吧哈哈哈。</p><p>而我，还是会在计算机这个方向摸爬滚打下去，我有着一份对这一行业的喜欢，不然我也不会转专业呢（毕竟也听说你也是计算机的哈哈哈）。</p><p>今天决定将自己已经复习大半的数一英一转为数二英二了，那些数一的内容真的有些复杂难懂，实在不想去搞清楚它了，决定考一个数二英二408的电子信息专硕，不也挺好嘛。</p><p>如果你想考研，你就加油考研呀，我会报考和你在同一座城市甚至同一所大学。</p><p>如果你没考研，你会待在杭州的咯？那我就考杭州这里的大学（虽然我想出去看看，但是我还是希望留下来陪你，所以如果你能考研，然后我们一起去同一座城市那就更好不过了）</p><p>和你聊的过程中，你真的一直在吐槽你自己呀，我已经超过三年没和你好好说过话了，发现你还是一如既往地丧呢，也希望你的消极的情绪还是越少越好喔。</p><p>你说你没有未来了，考研也考不上，工作也找不到，以后只能去蜜雪冰城打工了。</p><p><img src="/img/chat3.jpg"></p><p>没事，希望我以后努力，能有机会对你好呢</p><p>外加吃不完的摩天脆脆</p><p>哈哈……</p>]]></content>
    
    
    <categories>
      
      <category>YeahZH</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录一下（二）</title>
    <link href="/posts/46eabb4c.html"/>
    <url>/posts/46eabb4c.html</url>
    
    <content type="html"><![CDATA[<p>好像有些话不说出来也很难受…我还是打出来其实刚才想电视课下课去跟你聊聊的一转头你就不见了应该又去操场了吧我下午真的想了很久语文考试的时候也在想想了很多跟你的事觉得这么可爱的男孩子让我遇到真是太幸运了我好像也喜欢上他了呢!所以下午说的那些全都当放屁处理吧今天这么美好的日子我就谋划着等晚上一起站在天桥上跟他打开话匣子”嘿光棍节要不要一起脱个单呀”虽然小女生的幻想总是不能实现的哈哈哈也就自己想想了其实时间不是最主要的因素吧你现在被我”折磨”的忽冷忽热刚才你说”找别人去””那就更没什么好陪的了”是真的很扎心换做平常我肯定摔手机就不理你了但还是安慰自己”他又不是你的谁凭什么一定要一直对你那么热情呀”所以很怕在一起了你也这样况且如果在一起了我就更会认为你要对我好是理所应当的吧就会更难过了还有一个原因应该是所谓”别人的眼光”吧以前好像是挺不在乎别人怎么看的自从跟ljn的事之后…好像真的很听不得那些话更因为这种事又导致了lyh的事…我是真的很怕也很烦所以也想着如果可能的话我不想公开了…你应该不能接受吧已经有了一起去上海我也只能说自己一个人去这件事就算她们说不可能我也只能极力否认.…..这样好像做小偷一样遮遮掩掩的好没劲啊可是现在的我真的不知道怎么去面对”舆论”这种东西.…可能这些就是我一部分内心想法吧还有一些我大概也表达不出来了语言组织能力比较差.….哎我现在就是变成了自己最不喜欢的样子啦…比较坏吧你也就能包容则包容不能就…算了吧虽然这么说好像也有点扎心.…然后最近因为lyh其实心态真的也挺崩的啥也不想做吧不让你跟我一起吃饭就是因为我怕我不吃你也不吃这样对你不好…如果你还能继续包容的话希望你也不要跟刚才一样太冷漠吧要么就直接绝一点…不过我可能真的就要短时间内失去三个好朋友了…嗯反正就这么点话我好像啰嗦了挺多的也谢谢你以前一直受得了我这种怪脾气啦不过如果受不了了一定要告诉我我会尽量不对你发脾气的也尽量不让你太难过.….就这样吧这些东西应该挺走心的吧w</p>]]></content>
    
    
    <categories>
      
      <category>YeahZH</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录一下（一）</title>
    <link href="/posts/76fc5794.html"/>
    <url>/posts/76fc5794.html</url>
    
    <content type="html"><![CDATA[<p>深夜可能话唠，字也丑将就看吧。我好像也不是善解人意的孩子。</p><p>如果你知道这种感觉的话，HX也是一种觉得你心里我和YTX地位更高的感觉。所以她难受，她不开心，她不想理你。我刚看完你写的这个之后也很烦，又有一堆人来问我写了什么，然后我跟HX破罐子破摔了，两个人跟吵架一样，总之很难描述。结局反正我俩都抑制住快要哭的冲动，但可能都在被窝里默默流泪了吧。&lt;—神经病，我没有！以及由于我的破罐子破摔了再加上劝说无果，明天再努力一下，再不行的话，我也没啥办法了，对不起啦，这事儿我真得向您道歉，果然小女生的小心思只有女生才会懂吧，也可能是才17的我和HX有点像。</p><p>By the way，你和他的地位是没有办法分高低的，至少现在没办法，以及我也不懂他为什么对作为前女友的我比作为女朋友的我要好。如果是我的话，肯定对小女朋友全世界全宇宙第一好吧，而且不会有第二的那种。道理大家都懂，设身处地的话我也会难受，会压抑，但你莫名其妙地不理我我会更难受，更压抑。我也作，女孩子比男孩子作很多，也会丧更多吧。</p><p>明天也是要好好学习的一天，我只会理学习的，别来找我啦。</p><p>也希望您不被我影响到（？）祝您天天开心睡得香考得好，生病就好好休息，现在是23：49分，那你猜我有没有好好睡觉呢？&#x3D;D。</p>]]></content>
    
    
    <categories>
      
      <category>YeahZH</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
