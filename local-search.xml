<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一些算法</title>
    <link href="/posts/6b6cddb9.html"/>
    <url>/posts/6b6cddb9.html</url>
    
    <content type="html"><![CDATA[<h3 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h3><h4 id="1-对于一个2行N列的走道。现在用1x2或2x2的砖去铺满。问有多少种不同的方式（请用递推方式求解）。如果N很大，需要高精度计算。"><a href="#1-对于一个2行N列的走道。现在用1x2或2x2的砖去铺满。问有多少种不同的方式（请用递推方式求解）。如果N很大，需要高精度计算。" class="headerlink" title="1. 对于一个2行N列的走道。现在用1x2或2x2的砖去铺满。问有多少种不同的方式（请用递推方式求解）。如果N很大，需要高精度计算。"></a>1. 对于一个2行N列的走道。现在用1x2或2x2的砖去铺满。问有多少种不同的方式（请用递推方式求解）。如果N很大，需要高精度计算。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//（1）n=1，有1种方法，即1*2竖放</span><br><br><span class="hljs-comment">//（2）n=2，有3种方法</span><br><br><span class="hljs-comment">//（3）n&gt;=3，1*2竖放（占1列）有f(n-1)种方法，1*2横放（占2列）有f(n-2)种方法，2*2横放（占2列）有f(n-2)种方法，故：</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">pave</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pave</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-number">2</span> * <span class="hljs-built_in">pave</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n)<br>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-built_in">pave</span>(n) &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-在一个2-k×2-k-个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。"><a href="#2-在一个2-k×2-k-个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。" class="headerlink" title="2. 在一个2^k×2^k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。"></a>2. 在一个2^k×2^k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。</h4><p><img src="https://img-blog.csdnimg.cn/20200326114531158.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjY4NTcw,size_1,color_FFFFFF,t_70#pic_center"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;  <br><span class="hljs-type">int</span> g[N][N];  <br><span class="hljs-type">int</span> size,dx,dy;  <br><span class="hljs-type">int</span> title=<span class="hljs-number">1</span>;  <br><span class="hljs-comment">//左上角坐标、特殊骨牌坐标、长度  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">answer</span><span class="hljs-params">(<span class="hljs-type">int</span> lx,<span class="hljs-type">int</span> ly,<span class="hljs-type">int</span> dx,<span class="hljs-type">int</span> dy,<span class="hljs-type">int</span> size)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">if</span>(size==<span class="hljs-number">1</span>)  <br>    <span class="hljs-keyword">return</span>;  <br>    <span class="hljs-type">int</span> s=size/<span class="hljs-number">2</span>;  <br>    <span class="hljs-type">int</span> t=title++;  <br>    <span class="hljs-keyword">if</span>(dx&lt;lx+s&amp;&amp;dy&lt;ly+s) <span class="hljs-comment">//特殊坐标在左上角  </span><br>    &#123;  <br>        <span class="hljs-built_in">answer</span>(lx,ly,dx,dy,s);  <span class="hljs-comment">//在左上角分成四块继续递归</span><br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        g[lx+s<span class="hljs-number">-1</span>][ly+s<span class="hljs-number">-1</span>]=t;  <span class="hljs-comment">//如果不在左上角，则在该左上角区域的右下角填充</span><br>        <span class="hljs-built_in">answer</span>(lx,ly,lx+s<span class="hljs-number">-1</span>,ly+s<span class="hljs-number">-1</span>,s);  <span class="hljs-comment">//在左上角分成四块继续递归</span><br>    &#125;  <br>    <span class="hljs-keyword">if</span>(dx&lt;lx+s&amp;&amp;dy&gt;=ly+s)<span class="hljs-comment">//左下角  </span><br>    &#123;  <br>        <span class="hljs-built_in">answer</span>(lx,ly+s,dx,dy,s);  <span class="hljs-comment">//在左下角分成四块继续递归</span><br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        g[lx+s<span class="hljs-number">-1</span>][ly+s]=t;  <span class="hljs-comment">//如果不在左下角，则在该左下角区域的右上角填充</span><br>        <span class="hljs-built_in">answer</span>(lx,ly+s,lx+s<span class="hljs-number">-1</span>,ly+s,s);   <span class="hljs-comment">//在左下角分成四块继续递归</span><br>    &#125;  <br>    <span class="hljs-keyword">if</span>(dx&gt;=lx+s&amp;&amp;dy&lt;ly+s)  <span class="hljs-comment">//右上角</span><br>    &#123;  <br>        <span class="hljs-built_in">answer</span>(lx+s,ly,dx,dy,s);  <br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        g[lx+s][ly+s<span class="hljs-number">-1</span>]=t;  <br>        <span class="hljs-built_in">answer</span>(lx+s,ly,lx+s,ly+s<span class="hljs-number">-1</span>,s);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(dx&gt;=lx+s&amp;&amp;dy&gt;=ly+s)  <span class="hljs-comment">//右下角</span><br>    &#123;  <br>        <span class="hljs-built_in">answer</span>(lx+s,ly+s,dx,dy,s);  <br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        g[lx+s][ly+s]=t;  <br>        <span class="hljs-built_in">answer</span>(lx+s,ly+s,lx+s,ly+s,s);  <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-comment">//棋盘行数、特殊方格的行坐标、特殊方格的列坐标  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;size,&amp;dx,&amp;dy);  <br>    <span class="hljs-built_in">answer</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,dx,dy,size);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)  <br>    &#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=size;j++)  <br>        &#123;  <br>   <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d &quot;</span>,g[i][j]);  <br>        &#125;  <br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="3-在n枚外观相同的硬币中，有一枚是假币，并且已知假币与真币的重量不同，已知道假币比真币轻。可以通过一架天平来任意比较两组硬币，设计一个高效的算法来检测这枚假币。要求用分治法称重来实现。"><a href="#3-在n枚外观相同的硬币中，有一枚是假币，并且已知假币与真币的重量不同，已知道假币比真币轻。可以通过一架天平来任意比较两组硬币，设计一个高效的算法来检测这枚假币。要求用分治法称重来实现。" class="headerlink" title="3. 在n枚外观相同的硬币中，有一枚是假币，并且已知假币与真币的重量不同，已知道假币比真币轻。可以通过一架天平来任意比较两组硬币，设计一个高效的算法来检测这枚假币。要求用分治法称重来实现。"></a>3. 在n枚外观相同的硬币中，有一枚是假币，并且已知假币与真币的重量不同，已知道假币比真币轻。可以通过一架天平来任意比较两组硬币，设计一个高效的算法来检测这枚假币。要求用分治法称重来实现。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CheckMoney</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> sum1=<span class="hljs-number">0</span>, sum2=<span class="hljs-number">0</span>, sum3=<span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">if</span> ((right-left+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)      <span class="hljs-comment">//偶数  </span><br>    &#123;  <br>        <span class="hljs-keyword">if</span> (left + <span class="hljs-number">1</span> == right)  <br>        &#123;  <br>            <span class="hljs-keyword">if</span> (arr[left] &lt; arr[right])  <br>            &#123;  <br>                <span class="hljs-keyword">return</span> left;  <br>            &#125;  <br>            <span class="hljs-keyword">else</span>  <br>                <span class="hljs-keyword">return</span> right;  <br>        &#125;  <br>        <span class="hljs-type">int</span> mid = (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>+left;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=left; i&lt;mid; ++i)  <br>        &#123;  <br>            sum1 += arr[i];  <br>            sum2 += arr[right – i +left];  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (sum1&lt;sum2)  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">CheckMoney</span>(arr, left, mid - <span class="hljs-number">1</span>);  <br>   <br>        &#125;  <br>        <span class="hljs-keyword">else</span>  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">CheckMoney</span>(arr, mid, right);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">else</span>    <span class="hljs-comment">//奇数</span><br>    &#123;  <br>        <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span>+left;  <br>   <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=left; i&lt;mid; ++i)  <br>        &#123;  <br>            sum1 += arr[i];  <br>            sum2 += arr[right - i+left];  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (sum1&lt;sum2)  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">CheckMoney</span>(arr, left, mid - <span class="hljs-number">1</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum1&gt;sum2)  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">CheckMoney</span>(arr, mid+<span class="hljs-number">1</span>, right);  <br>        &#125;  <br>        <span class="hljs-keyword">else</span>  <br>        &#123;  <br>            <span class="hljs-keyword">return</span> mid;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>   <br>    <span class="hljs-type">int</span> arr[]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;  <br>    std::cout&lt;&lt;<span class="hljs-string">&quot;false coin positon &quot;</span> &lt;&lt; <span class="hljs-built_in">CheckMoney</span>(arr, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)+<span class="hljs-number">1</span>&lt;&lt;std::endl;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="4-组合学中有这样一个问题：某人给五个朋友写信，邀请他们来家中聚会。请柬和信封交由助手去处理。粗心的助手却把请柬全装错了信封。请问：助手会有多少种装错的可能呢？"><a href="#4-组合学中有这样一个问题：某人给五个朋友写信，邀请他们来家中聚会。请柬和信封交由助手去处理。粗心的助手却把请柬全装错了信封。请问：助手会有多少种装错的可能呢？" class="headerlink" title="4. 组合学中有这样一个问题：某人给五个朋友写信，邀请他们来家中聚会。请柬和信封交由助手去处理。粗心的助手却把请柬全装错了信封。请问：助手会有多少种装错的可能呢？"></a>4. 组合学中有这样一个问题：某人给五个朋友写信，邀请他们来家中聚会。请柬和信封交由助手去处理。粗心的助手却把请柬全装错了信封。请问：助手会有多少种装错的可能呢？</h4><p>$$<br>D_{n} = (n-1)(D_{n-1}+D_{n-2})<br>$$</p><p>$$<br>D_{1}=0,D_{2}=1<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span>  </span><br>  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span><span class="hljs-comment">//一定要开long long  </span></span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">if</span>( x == <span class="hljs-number">1</span> )  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x == <span class="hljs-number">2</span> )  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">else</span>  <br>        <span class="hljs-built_in">return</span> (x<span class="hljs-number">-1</span>)*(<span class="hljs-built_in">f</span>(x<span class="hljs-number">-1</span>)+<span class="hljs-built_in">f</span>(x<span class="hljs-number">-2</span>));  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> n;  <br>    cin&gt;&gt;n;  <br>    cout&lt;&lt;<span class="hljs-built_in">f</span>(n);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h3><h4 id="1-双11到了，据说这2天会下红包雨，每个红包有不同的价值，小k好开心，但有个规则，就只能接掉落在他身旁的10米范围内的红包（0-10这11个位置）。小k想尽可能的多抢红包，这样就可以去买一个华为手机，小k每秒种只能在移动不超过一米的范围内接住红包。小k一开始站在5这个位置，因此在第一秒，他只能接到4-5-6这三个位置中其中一个位置上的红包。问小k最多可能接到多少价值的红包？"><a href="#1-双11到了，据说这2天会下红包雨，每个红包有不同的价值，小k好开心，但有个规则，就只能接掉落在他身旁的10米范围内的红包（0-10这11个位置）。小k想尽可能的多抢红包，这样就可以去买一个华为手机，小k每秒种只能在移动不超过一米的范围内接住红包。小k一开始站在5这个位置，因此在第一秒，他只能接到4-5-6这三个位置中其中一个位置上的红包。问小k最多可能接到多少价值的红包？" class="headerlink" title="1. 双11到了，据说这2天会下红包雨，每个红包有不同的价值，小k好开心，但有个规则，就只能接掉落在他身旁的10米范围内的红包（0-10这11个位置）。小k想尽可能的多抢红包，这样就可以去买一个华为手机，小k每秒种只能在移动不超过一米的范围内接住红包。小k一开始站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的红包。问小k最多可能接到多少价值的红包？"></a>1. 双11到了，据说这2天会下红包雨，每个红包有不同的价值，小k好开心，但有个规则，就只能接掉落在他身旁的10米范围内的红包（0-10这11个位置）。小k想尽可能的多抢红包，这样就可以去买一个华为手机，小k每秒种只能在移动不超过一米的范围内接住红包。小k一开始站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中其中一个位置上的红包。问小k最多可能接到多少价值的红包？</h4><p><strong>Input</strong><br><strong>第一行输入整数n，表示共有多少个红包，n&lt;1000；</strong><br><strong>后面n行表示n个红包，每行有三个整数，分别表示红包掉落的位置、时间和价值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-type">int</span> dp[<span class="hljs-number">1010</span>][<span class="hljs-number">12</span>];  <span class="hljs-comment">// dp[i][j]表示i时刻j位置开始出发，到最终时间点所获得的最大红包数   </span><br>  <br><span class="hljs-comment">//两个数中的最大值  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max_2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">return</span> (a&gt;b) ? a :b;  <br>&#125;   <br>  <br><span class="hljs-comment">//三个数中的最大值  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxn</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> max = (a&gt;b) ? a : b;  <br>    <span class="hljs-keyword">return</span> (max&gt;c) ? max : c;  <br>&#125;   <br>  <br><span class="hljs-comment">// 计算最优值  </span><br><span class="hljs-comment">// 状态转移方程为：dp[i][j]=maxn(dp[i+1][j-1]，dp[i+1][j]，dp[i+1][j+1])  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span> max_time)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=max_time<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">12</span>; j++)&#123;  <br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)  <span class="hljs-comment">// 在第0位置，下一秒只能原地或向右移动   </span><br>                dp[i][j] = <span class="hljs-built_in">max_2</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) + dp[i][j];  <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">11</span>)   <span class="hljs-comment">// 在第11位置，下一秒只能原地或向左移动   </span><br>                dp[i][j] = <span class="hljs-built_in">max_2</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]) + dp[i][j];  <br>            <span class="hljs-keyword">else</span>  <br>                dp[i][j] = <span class="hljs-built_in">maxn</span>(dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>],dp[i+<span class="hljs-number">1</span>][j],dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])+ dp[i][j];  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> n;  <br>    cin &gt;&gt; n;  <br>    <span class="hljs-type">int</span> location, time, value;  <br>    <span class="hljs-type">int</span> max_time = <span class="hljs-number">-1</span>;  <br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));  <br>    <span class="hljs-comment">// 保存输入的数据到数组中   </span><br>    <span class="hljs-keyword">while</span>(n--)&#123;  <br>        cin &gt;&gt; location &gt;&gt; time &gt;&gt; value;  <br>        dp[time][location] = value;  <br>        <span class="hljs-keyword">if</span>(time &gt; max_time) max_time = time;  <br>    &#125;   <br>    <span class="hljs-built_in">maxValue</span>(max_time);  <br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>][<span class="hljs-number">4</span>] &lt;&lt; endl;  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="2-给出长度为n的数组，求最大连续子段和，-输出该最大和。"><a href="#2-给出长度为n的数组，求最大连续子段和，-输出该最大和。" class="headerlink" title="2. 给出长度为n的数组，求最大连续子段和， 输出该最大和。"></a>2. 给出长度为n的数组，求最大连续子段和， 输出该最大和。</h4><p><strong>Input</strong><br><strong>第1行输入一个整数n&lt;50；表示输入数组的大小</strong><br><strong>第2行输入n个数，中间用空格隔开</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, nums[<span class="hljs-number">51</span>];  <br>    <span class="hljs-type">int</span> max;<br>    cin &gt;&gt; n;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)  <br>        cin &gt;&gt; nums[i];  <br>    max = nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//初始令最大值为第一个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;  <br>        <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//判断到前一个数为止的最大子序列和是否大于0</span><br>            nums[i] += nums[i - <span class="hljs-number">1</span>];<span class="hljs-comment">//若大于0，则继续扩大子序列</span><br>        <span class="hljs-keyword">if</span> (max &lt; nums[i])<br>            max = nums[i];<span class="hljs-comment">//更新最大值</span><br>    &#125;  <br>    cout &lt;&lt; max &lt;&lt; endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="3-小K是个苦命的孩子，他的师傅为了多赚钱，以减肥为理由，让他去采药，并说不完成不能吃饭。野地里有许多不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。要求在规定的时间t里，采到的草药的总价值最大。"><a href="#3-小K是个苦命的孩子，他的师傅为了多赚钱，以减肥为理由，让他去采药，并说不完成不能吃饭。野地里有许多不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。要求在规定的时间t里，采到的草药的总价值最大。" class="headerlink" title="3. 小K是个苦命的孩子，他的师傅为了多赚钱，以减肥为理由，让他去采药，并说不完成不能吃饭。野地里有许多不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。要求在规定的时间t里，采到的草药的总价值最大。"></a>3. 小K是个苦命的孩子，他的师傅为了多赚钱，以减肥为理由，让他去采药，并说不完成不能吃饭。野地里有许多不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。要求在规定的时间t里，采到的草药的总价值最大。</h4><p><strong>Input</strong><br><strong>第一行有2个整数T(1≤T≤1000)和M(1≤M≤100)，一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。</strong><br><strong>接下来的M行每行包括两个在1到100之间包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1005</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br><span class="hljs-type">int</span> dp[maxn], w[maxn], c[maxn];  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> t, m;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;t, &amp;m);   <span class="hljs-comment">//输入总的采摘时间和草药数目</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;c[i], &amp;w[i]);    <span class="hljs-comment">//分别输入每株草药的时间和价值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = t; j &gt;= c[i]; j--)  <br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j - c[i]] + w[i], dp[j]);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[t]);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="4-给定两个字符串，求解这两个字符串的最长非连续（允许连续或非连续）的公共子序列的长度（Longest-Common-Sequence）。"><a href="#4-给定两个字符串，求解这两个字符串的最长非连续（允许连续或非连续）的公共子序列的长度（Longest-Common-Sequence）。" class="headerlink" title="4. 给定两个字符串，求解这两个字符串的最长非连续（允许连续或非连续）的公共子序列的长度（Longest Common Sequence）。"></a>4. 给定两个字符串，求解这两个字符串的最长非连续（允许连续或非连续）的公共子序列的长度（Longest Common Sequence）。</h4><p>比如字符串1：BDCABA；字符串2：ABCBDAB。<br>则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA<br><strong>Input</strong><br>输入2行，每行一个字符串；字符串长度&lt;1000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>] = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">//记录动态规划结果</span><br>string s1, s2;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLCS</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">length</span>(), m = s2.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j++) &#123;<br>            <span class="hljs-keyword">if</span> (s1[i - <span class="hljs-number">1</span>] == s2[j - <span class="hljs-number">1</span>]) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">//若当前两个指针指向的字符相等,在斜对角的基础上加1</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//若当前两个指针指向的字符不相等,则在两边找一个最大值</span><br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<span class="hljs-comment">//解两个子问题</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; s1 &gt;&gt; s2;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">findLCS</span>();<br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-一家公司购买长钢条，将其切割成短钢条出售，切割本身没有成本，长度为i的短钢条的价格为Pi。那给定一段长度为n的钢条和一个价格表Pi-求钢条的切割方案使得收益Rn最大。"><a href="#5-一家公司购买长钢条，将其切割成短钢条出售，切割本身没有成本，长度为i的短钢条的价格为Pi。那给定一段长度为n的钢条和一个价格表Pi-求钢条的切割方案使得收益Rn最大。" class="headerlink" title="5. 一家公司购买长钢条，将其切割成短钢条出售，切割本身没有成本，长度为i的短钢条的价格为Pi。那给定一段长度为n的钢条和一个价格表Pi,求钢条的切割方案使得收益Rn最大。"></a>5. 一家公司购买长钢条，将其切割成短钢条出售，切割本身没有成本，长度为i的短钢条的价格为Pi。那给定一段长度为n的钢条和一个价格表Pi,求钢条的切割方案使得收益Rn最大。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> steel_len;<span class="hljs-comment">//钢条原始长度，也是钢条种类的数量</span><br><span class="hljs-type">int</span> steel[<span class="hljs-number">11</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">17</span>,<span class="hljs-number">17</span>,<span class="hljs-number">20</span>,<span class="hljs-number">24</span>,<span class="hljs-number">30</span> &#125;; <span class="hljs-comment">//记录已知长度钢条价值</span><br><span class="hljs-comment">//动规解法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-type">int</span>* arr_dp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[len + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(arr_dp, <span class="hljs-number">0</span>, (len + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//初始化为0</span><br>    <span class="hljs-comment">//对于dp表的每一项（钢条总长度）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>        <span class="hljs-comment">//首段长度j</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>            arr_dp[i] = <span class="hljs-built_in">max</span>(arr_dp[i], steel[j] + arr_dp[i - j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr_dp[len];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; steel_len;<br>    cout &lt;&lt; <span class="hljs-built_in">dp</span>(steel_len) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-一条街上有N个商铺；商铺i有价值V-i-的物品，你有足够的时间在晚上光顾所有的商店，人们称呼你为盗贼；每个商店都有一个报警器，会在晚上报警，但是只有相邻的2个商店同时报警时，警察才会出动；你需要证明你是个合格的盗贼。输出偷盗的最大价值。"><a href="#6-一条街上有N个商铺；商铺i有价值V-i-的物品，你有足够的时间在晚上光顾所有的商店，人们称呼你为盗贼；每个商店都有一个报警器，会在晚上报警，但是只有相邻的2个商店同时报警时，警察才会出动；你需要证明你是个合格的盗贼。输出偷盗的最大价值。" class="headerlink" title="6. 一条街上有N个商铺；商铺i有价值V[i]的物品，你有足够的时间在晚上光顾所有的商店，人们称呼你为盗贼；每个商店都有一个报警器，会在晚上报警，但是只有相邻的2个商店同时报警时，警察才会出动；你需要证明你是个合格的盗贼。输出偷盗的最大价值。"></a>6. 一条街上有N个商铺；商铺i有价值V[i]的物品，你有足够的时间在晚上光顾所有的商店，人们称呼你为盗贼；每个商店都有一个报警器，会在晚上报警，但是只有相邻的2个商店同时报警时，警察才会出动；你需要证明你是个合格的盗贼。输出偷盗的最大价值。</h4><p><strong>Input</strong></p><p>第一行一个整数N&lt;=100，商店数。</p><p>第二行N个整数，每个商店的价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt;= n;i++) &#123;<br>        dp[i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">3</span>] + dp[i - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 动态规划递推关系</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        cin &gt;&gt; dp[i];<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">findMaxValue</span>(n);<br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、贪心"><a href="#三、贪心" class="headerlink" title="三、贪心"></a>三、贪心</h3><h4 id="1-小K没事干，他要搬砖头，为了达到较好的减肥效果，教练规定的方式很特别：每一次，小K可以把两堆砖头合并到一起，消耗的体力等于两堆砖头的重量之和。经过-n-1次合并后，-就只剩下一堆了。小K在搬砖头时总共消耗的体力等于每次合并所耗体力之和。小K为了偷懒，希望耗费的体力最小。"><a href="#1-小K没事干，他要搬砖头，为了达到较好的减肥效果，教练规定的方式很特别：每一次，小K可以把两堆砖头合并到一起，消耗的体力等于两堆砖头的重量之和。经过-n-1次合并后，-就只剩下一堆了。小K在搬砖头时总共消耗的体力等于每次合并所耗体力之和。小K为了偷懒，希望耗费的体力最小。" class="headerlink" title="1. 小K没事干，他要搬砖头，为了达到较好的减肥效果，教练规定的方式很特别：每一次，小K可以把两堆砖头合并到一起，消耗的体力等于两堆砖头的重量之和。经过 n-1次合并后， 就只剩下一堆了。小K在搬砖头时总共消耗的体力等于每次合并所耗体力之和。小K为了偷懒，希望耗费的体力最小。"></a>1. 小K没事干，他要搬砖头，为了达到较好的减肥效果，教练规定的方式很特别：每一次，小K可以把两堆砖头合并到一起，消耗的体力等于两堆砖头的重量之和。经过 n-1次合并后， 就只剩下一堆了。小K在搬砖头时总共消耗的体力等于每次合并所耗体力之和。小K为了偷懒，希望耗费的体力最小。</h4><p>例如有 3堆砖头，数目依次为 1、2、9 。可以先将 1 、 2 堆合并，新堆数目为3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为12 。所以总共耗费体力 =3+12=15。可以证明 15为最小的体力耗费值。</p><p><strong>Input</strong><br>共两行。</p><p>第一行是一个整数 n(1≤n≤1000) ，表示砖头堆数。</p><p>第二行n个整数，每个整数表示每堆砖头的砖头块数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">1000</span>],sum=<span class="hljs-number">0</span>,i;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(a, a + n);<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-type">int</span> temp = a[i + <span class="hljs-number">1</span>] + a[i];<span class="hljs-comment">//记录前两个最小的值</span><br><span class="hljs-type">int</span> k = i + <span class="hljs-number">2</span>;<span class="hljs-comment">//k为第三个的下标</span><br><span class="hljs-keyword">while</span> (a[k] &lt; temp &amp;&amp; k &lt; n) &#123;<span class="hljs-comment">//比较第三个和前两个的和，若第三个比前两个要小</span><br>a[k - <span class="hljs-number">1</span>] = a[k];<span class="hljs-comment">//把第三个值前移，</span><br>k++;  <span class="hljs-comment">//一直循环，直到后面比两个最小值的和小的数都移到前面</span><br>&#125;<br>a[k - <span class="hljs-number">1</span>] = temp; <br>sum += temp;<br><br>&#125;<br>cout &lt;&lt; sum &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-给定一个非负整数数组，假定你的初始位置为数组第一个位置。数组中的每个元素代表你在那个位置能够跳跃的最大长度。你的目标是到达最后一个下标位置，并且使用最少的跳跃次数。"><a href="#2-给定一个非负整数数组，假定你的初始位置为数组第一个位置。数组中的每个元素代表你在那个位置能够跳跃的最大长度。你的目标是到达最后一个下标位置，并且使用最少的跳跃次数。" class="headerlink" title="2. 给定一个非负整数数组，假定你的初始位置为数组第一个位置。数组中的每个元素代表你在那个位置能够跳跃的最大长度。你的目标是到达最后一个下标位置，并且使用最少的跳跃次数。"></a>2. 给定一个非负整数数组，假定你的初始位置为数组第一个位置。数组中的每个元素代表你在那个位置能够跳跃的最大长度。你的目标是到达最后一个下标位置，并且使用最少的跳跃次数。</h4><p><strong>Input</strong></p><p>输入一组非负整数数组，数组长度不超过500。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, a[<span class="hljs-number">501</span>];<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; a[n++]);<br>    n = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// maxPos 记录当前最远能到哪里</span><br>    <span class="hljs-comment">// step 记录当前进行了几跳</span><br>    <span class="hljs-comment">// end 记录了当前最远能到哪里的边界</span><br>    <span class="hljs-type">int</span> maxPos = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>, step = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n - <span class="hljs-number">1</span>;i++) &#123;<br>        <span class="hljs-keyword">if</span> (maxPos &gt;= i) &#123; <span class="hljs-comment">//判断能否继续探索</span><br>            maxPos = <span class="hljs-built_in">max</span>(maxPos, i + a[i]);<br>            <span class="hljs-keyword">if</span> (i == end) &#123; <span class="hljs-comment">// 到达边界更新跳数</span><br>                end = maxPos;<br>                step++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; step &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-给出n个区间的起点和终点，求最少使用其中多少个区间可以将所有区间所在的区域完全覆盖。（测试的数据确保这1点）。"><a href="#3-给出n个区间的起点和终点，求最少使用其中多少个区间可以将所有区间所在的区域完全覆盖。（测试的数据确保这1点）。" class="headerlink" title="3. 给出n个区间的起点和终点，求最少使用其中多少个区间可以将所有区间所在的区域完全覆盖。（测试的数据确保这1点）。"></a>3. 给出n个区间的起点和终点，求最少使用其中多少个区间可以将所有区间所在的区域完全覆盖。（测试的数据确保这1点）。</h4><p><strong>Input</strong></p><p>第1行一个整数n，表示n个区间；</p><p>第2行开始n行，每行2个整数，表示一个区间范围。</p><p>类似[1,4][5,6]被认为是覆盖了[1,6]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//先按开始点升序，结束点升序将数据排序。为了使覆盖总区间的所需的子区间数最少，就要选出一系列覆盖范围最广的子区间</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">part</span><span class="hljs-comment">//区间两端</span><br>&#123;<br>    <span class="hljs-type">int</span> star1, end1;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(part s1, part s2)</span> </span>&#123; <span class="hljs-comment">// 自定义排序方式1、开始点升序，2、结束点升序</span><br>    <span class="hljs-keyword">if</span> (s1.star1 &lt; s2.star1)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s1.star1 == s2.star1 &amp;&amp; s1.end1 &lt; s2.end1)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    part a[<span class="hljs-number">100</span>];<span class="hljs-comment">//全部待选区间</span><br>    part r[<span class="hljs-number">100</span>];<br>    <span class="hljs-comment">//在a中选好的数放入r中</span><br> <br>    <span class="hljs-type">int</span> n, index = <span class="hljs-number">0</span>, i;<br> <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i].star1 &gt;&gt; a[i].end1;<br>    &#125;<br> <br>    <span class="hljs-built_in">sort</span>(a, a + n, cmp);<br> <br>    <span class="hljs-type">int</span> right = a[<span class="hljs-number">0</span>].star1 - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = a[n - <span class="hljs-number">1</span>].end1; <span class="hljs-comment">// 待覆盖区间最远处</span><br> <br> <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; )<br>    &#123;<br>        <span class="hljs-type">int</span> maRight = a[i].end1, maIndex = i;<br> <br> <br>        <span class="hljs-keyword">while</span> (a[i].star1 &lt;= right + <span class="hljs-number">1</span> &amp;&amp; i &lt; n) &#123; <span class="hljs-comment">// 寻找最远子区间</span><br>            <span class="hljs-keyword">if</span> (a[i].end1 &gt; maRight) &#123;<br>                maRight = a[i].end1;<br>                maIndex = i;<br>            &#125;<br>            i++;  <span class="hljs-comment">//比较完数组往后移</span><br>        &#125;<br>        right = maRight;<br>        r[index++] = a[maIndex];<br>        i = maIndex;<br>        <span class="hljs-keyword">if</span> (right == end)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>        cout &lt;&lt; r[i].star1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r[i].end1 &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-一条街的一边有几座房子。因为环保原因居民想要在路边种些树，路边的地区被分割成块，并被编号成1-N；每个部分为一个单位尺寸大小并最多可种一棵树，每个居民想在门前种些树并指定了三个号码B-E-T，这三个数表示该居民想在B和E之间最少种T棵树。当然，B≤E-居民必须记住在指定区不能种多于区域地块数的树，所以T≤E-B-l。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。"><a href="#4-一条街的一边有几座房子。因为环保原因居民想要在路边种些树，路边的地区被分割成块，并被编号成1-N；每个部分为一个单位尺寸大小并最多可种一棵树，每个居民想在门前种些树并指定了三个号码B-E-T，这三个数表示该居民想在B和E之间最少种T棵树。当然，B≤E-居民必须记住在指定区不能种多于区域地块数的树，所以T≤E-B-l。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。" class="headerlink" title="4. 一条街的一边有几座房子。因为环保原因居民想要在路边种些树，路边的地区被分割成块，并被编号成1..N；每个部分为一个单位尺寸大小并最多可种一棵树，每个居民想在门前种些树并指定了三个号码B,E,T，这三个数表示该居民想在B和E之间最少种T棵树。当然，B≤E,居民必须记住在指定区不能种多于区域地块数的树，所以T≤E-B+l。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。"></a>4. 一条街的一边有几座房子。因为环保原因居民想要在路边种些树，路边的地区被分割成块，并被编号成1..N；每个部分为一个单位尺寸大小并最多可种一棵树，每个居民想在门前种些树并指定了三个号码B,E,T，这三个数表示该居民想在B和E之间最少种T棵树。当然，B≤E,居民必须记住在指定区不能种多于区域地块数的树，所以T≤E-B+l。居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。</h4><p><strong>Input</strong></p><p>第一行包含数据N，区域的个数；</p><p>第二行包含H，房子的数目；</p><p>下面的H行描述居民们的需要:B E T。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-type">int</span> n, m, k, ans;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> <span class="hljs-comment">// 保存要求数据</span><br>&#123;<br>    <span class="hljs-type">int</span> b, e, t;<br>&#125;a[<span class="hljs-number">5005</span>];<br><span class="hljs-type">bool</span> used[<span class="hljs-number">30005</span>]; <span class="hljs-comment">// 记录该位置是否种过树</span><br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> node&amp; a, <span class="hljs-type">const</span> node&amp; b)</span> <span class="hljs-comment">// 自定义排序方式</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.e &lt; b.e;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++) <span class="hljs-comment">// 输入数据</span><br>    &#123;<br>        cin &gt;&gt; a[i].b &gt;&gt; a[i].e &gt;&gt; a[i].t;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a, a + m, cmp);<br>    <span class="hljs-built_in">memset</span>(used, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(used)); <span class="hljs-comment">//初始化每个位置都没种过树</span><br>    ans = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录所需树的数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)<br>    &#123;<br>        k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = a[i].b;j &lt;= a[i].e;j++) <span class="hljs-comment">// 求在该要求区间内已经种了多少树</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (used[j]) k++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt;= a[i].t) <span class="hljs-comment">// 未达到要求</span><br>            <span class="hljs-keyword">continue</span>;<br>        k = a[i].t - k;  <span class="hljs-comment">// 还要种的数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = a[i].e;j &gt;= a[i].b;j--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (used[j] == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 寻找没种过的位置</span><br>            &#123;<br>                used[j] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//种树</span><br>                ans++;<br>                k--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、搜索"><a href="#四、搜索" class="headerlink" title="四、搜索"></a>四、搜索</h3><h4 id="1-有一个由数字-0、1-组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1-包围构成，每个节点只能走上下左右-4-个方向。现要求把封闭区域内的所有空间都填写成2。"><a href="#1-有一个由数字-0、1-组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1-包围构成，每个节点只能走上下左右-4-个方向。现要求把封闭区域内的所有空间都填写成2。" class="headerlink" title="1. 有一个由数字 0、1 组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1 包围构成，每个节点只能走上下左右 4 个方向。现要求把封闭区域内的所有空间都填写成2。"></a>1. 有一个由数字 0、1 组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1 包围构成，每个节点只能走上下左右 4 个方向。现要求把封闭区域内的所有空间都填写成2。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> mp[maxn][maxn], vis[maxn][maxn], n;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt; n - <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">0</span> || y &gt; n - <span class="hljs-number">1</span> || vis[x][y] || mp[x][y] != <span class="hljs-number">0</span>)  <span class="hljs-comment">//走到头了被封住了</span><br>        <span class="hljs-keyword">return</span>;<br>    vis[x][y] = <span class="hljs-number">1</span>;  <span class="hljs-comment">//如果不是边界，且没有访问过，且map[x][y]为0，走得通，标个1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)  <span class="hljs-comment">//四个方位都跑一跑</span><br>        <span class="hljs-built_in">dfs</span>(x + dir[i][<span class="hljs-number">0</span>], y + dir[i][<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mp[i][j]);<br>            vis[i][j] = mp[i][j];<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, i), <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, i), <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>), <span class="hljs-built_in">dfs</span>(i, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, vis[i][j] ? mp[i][j] : <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-有一个由数字-0、1-组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1-包围构成，每个节点只能走上下左右-4-个方向。现要求只把【最大封闭区域】内的空间填写成2-。"><a href="#2-有一个由数字-0、1-组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1-包围构成，每个节点只能走上下左右-4-个方向。现要求只把【最大封闭区域】内的空间填写成2-。" class="headerlink" title="2. 有一个由数字 0、1 组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1 包围构成，每个节点只能走上下左右 4 个方向。现要求只把【最大封闭区域】内的空间填写成2 。"></a>2. 有一个由数字 0、1 组成的方阵中，存在一任意形状的封闭区域，封闭区域由数字1 包围构成，每个节点只能走上下左右 4 个方向。现要求只把【最大封闭区域】内的空间填写成2 。</h4><p><strong>Input</strong></p><p>每组测试数据第一行一个整数 n(1≤n≤30)</p><p>接下来 n 行，由 0 和 1 组成的 n×n 的方阵。</p><p>封闭区域内至少有一个0，测试数据保证最大区域只有一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> mp[maxn][maxn], n, idx = <span class="hljs-number">2</span>, num = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt; n - <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">0</span> || y &gt; n - <span class="hljs-number">1</span> || mp[x][y] != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span>;<br>    mp[x][y] = idx;<br>    num++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        <span class="hljs-built_in">dfs</span>(x + dir[i][<span class="hljs-number">0</span>], y + dir[i][<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mp[i][j]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>), <span class="hljs-built_in">dfs</span>(i, n - <span class="hljs-number">1</span>), <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, i), <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span> (!mp[i][j])<br>            &#123;<br>                num = <span class="hljs-number">0</span>;<br>                idx++;<br>                <span class="hljs-built_in">dfs</span>(i, j);<br>                <span class="hljs-keyword">if</span> (num &gt; mx)<br>                &#123;<br>                    ans = idx;<br>                    mx = num;<br>                &#125;<br>            &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, mp[i][j] == ans ? <span class="hljs-number">2</span> : (mp[i][j] == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-给定图G-V-E-，需要为图G的各顶点着色，是否有一种着色法使G中相邻的两个顶点有不同的颜色"><a href="#3-给定图G-V-E-，需要为图G的各顶点着色，是否有一种着色法使G中相邻的两个顶点有不同的颜色" class="headerlink" title="3. 给定图G=(V, E)，需要为图G的各顶点着色，是否有一种着色法使G中相邻的两个顶点有不同的颜色?"></a>3. 给定图G=(V, E)，需要为图G的各顶点着色，是否有一种着色法使G中相邻的两个顶点有不同的颜色?</h4><p><strong>Input</strong></p><p>第一行是顶点的个数n（2≤n≤8），颜色数m（1≤m≤n）。</p><p>接下来是顶点之间的连接关系：a b；表示a和b相邻。顶点从1开始计。</p><p>当a，b同时为0时表示输入结束。</p><p><strong>输出着色方案总数和最少颜色数。如果无可行方案，颜色数为0。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">G</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> a[maxn], n, m, ans, mn = inf;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[x].<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[x] == a[G[x][i]])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt; n)<br>    &#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            s.<span class="hljs-built_in">insert</span>(a[i]);<br>        mn = <span class="hljs-built_in">min</span>(mn, <span class="hljs-built_in">int</span>(s.<span class="hljs-built_in">size</span>()));<br>        ans++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        a[x] = i;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(x))<br>            <span class="hljs-built_in">solve</span>(x + <span class="hljs-number">1</span>);<br>        a[x] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        G[x].<span class="hljs-built_in">push_back</span>(y);<br>        G[y].<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, ans, mn == inf ? <span class="hljs-number">0</span> : mn);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-N皇后的排列，每行一个不冲突；N-lt-13。"><a href="#4-N皇后的排列，每行一个不冲突；N-lt-13。" class="headerlink" title="4. N皇后的排列，每行一个不冲突；N&lt;=13。"></a>4. N皇后的排列，每行一个不冲突；N&lt;=13。</h4><p><strong>输入要求</strong><br>一个数字N (6 &lt;= N &lt;= 13) 表示棋盘是N x N大小的。</p><p><strong>输出要求</strong><br>前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。<br>解的输出顺序为从上到下从左到右，小的优先输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> q[<span class="hljs-number">15</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queen</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> j;<br><span class="hljs-type">int</span> col,flag;<br><br><br><span class="hljs-keyword">if</span>(i==n+<span class="hljs-number">1</span>)<span class="hljs-comment">//所有的行全部走完，即成功找到一种解法</span><br>    &#123;<span class="hljs-comment">//注意是n+1因为只有到n+1才说明前n行都ok</span><br>            sum++;<br><br>            <span class="hljs-keyword">if</span>(sum&lt;=<span class="hljs-number">3</span>)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>                &#123;<span class="hljs-keyword">if</span>(j==n)<br>                       cout&lt;&lt;q[j]&lt;&lt;endl;<br>                    <span class="hljs-keyword">else</span><br>                        cout&lt;&lt;q[j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>            &#125;<br>                <span class="hljs-keyword">return</span> ;<br>    &#125;<br><span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(col=<span class="hljs-number">1</span>;col&lt;=n;col++)<span class="hljs-comment">//遍历i行的每一列,检查有没有可以的</span><br>        &#123;<br>            flag=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;i;j++)<span class="hljs-comment">//遍历前i行是否符合</span><br>                &#123;<span class="hljs-keyword">if</span>(col==q[j]||i-col==j-q[j]||i+col==j+q[j])<br>                    &#123;<br>                    <span class="hljs-comment">//前面几行中已经在这一列有皇后了</span><br>                    <span class="hljs-comment">//在主对角线中，其行与列的差相同即i-col==j-q[j]</span><br>                    <span class="hljs-comment">//在副对角线中，其行与列的和相同即i+col==j+q[j]</span><br>                    flag=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>                &#123;<br>                q[i]=col;<br>                <span class="hljs-built_in">queen</span>(i+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-built_in">memset</span>(q,<span class="hljs-number">15</span>,<span class="hljs-built_in">sizeof</span>(q));<span class="hljs-comment">//q数组即皇后所在的列的位置，q[j]即皇后位于第j行第q[j]列</span><br><span class="hljs-built_in">queen</span>(<span class="hljs-number">1</span>);<br>cout&lt;&lt;sum&lt;&lt;endl;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
